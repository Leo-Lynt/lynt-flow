function p({nodeData:c,context:o}){const f=c.parameters||[],i={};return f.forEach(t=>{var l;const Y=t.name;let e=((l=o.inputValues)==null?void 0:l[Y])??t.defaultValue;if(t.type==="date"&&e){const $=t.dateFormat||"DD/MM/YYYY";let a=null;if(typeof e=="string"&&/^\d{4}-\d{2}-\d{2}$/.test(e)){const[n,r,s]=e.split("-").map(Number);a=new Date(n,r-1,s)}else typeof e=="string"?a=new Date(e):e instanceof Date&&(a=e);if(a&&!isNaN(a.getTime())){const n=a.getFullYear(),r=String(a.getMonth()+1).padStart(2,"0"),s=String(a.getDate()).padStart(2,"0");switch($){case"DD/MM/YYYY":e=`${s}/${r}/${n}`;break;case"MM/DD/YYYY":e=`${r}/${s}/${n}`;break;case"YYYY-MM-DD":e=`${n}-${r}-${s}`;break;case"DD-MM-YYYY":e=`${s}-${r}-${n}`;break;case"YYYY/MM/DD":e=`${n}/${r}/${s}`;break;default:e=`${s}/${r}/${n}`}}}if((t.type==="number"||t.type==="integer"||t.type==="float")&&typeof e=="string"&&(e=t.type==="integer"?parseInt(e,10):parseFloat(e)),(t.type==="array"||t.type==="object")&&typeof e=="string")try{e=JSON.parse(e)}catch($){console.warn(`Failed to parse ${t.type} for parameter ${Y}:`,$)}i[Y]=e}),i}function u(c){const o=[];return(c.parameters||[]).forEach((i,t)=>{i.name||o.push(`Parâmetro no índice ${t} não possui nome`),i.type||o.push(`Parâmetro "${i.name}" não possui tipo`)}),{valid:o.length===0,errors:o}}export{p as execute,u as validate};
